# 3. 其他自定义修改

## 3.1 LLM Prompt 增加 reasoning 字段（实体抽取入库）

**文件**:
- `graphiti_core/prompts/extract_nodes.py`
- `graphiti_core/prompts/extract_edges.py`
- `graphiti_core/prompts/dedupe_edges.py`
- `graphiti_core/nodes.py` - EntityNode 模型增加 reasoning 字段
- `graphiti_core/utils/maintenance/node_operations.py` - 提取 reasoning 并保存
- `graphiti_core/utils/bulk_utils.py` - 批量保存包含 reasoning

**目的**: 让 LLM 输出推理过程，提高抽取准确性（Chain of Thought），并将实体的 reasoning 入库供后续分析和调试。

**修改的模型**:

| 文件 | 模型 | 新增字段 |
|-----|------|---------|
| `extract_nodes.py` | `ExtractedEntity` | `reasoning: str` - 解释为什么抽取该实体及类型选择原因 |
| `extract_nodes.py` | `EntitiesToFilter` | `reasoning: str` - 解释为什么过滤这些实体 |
| `extract_edges.py` | `Edge` | `reasoning: str` - 解释为什么抽取该关系及类型选择原因 |
| `dedupe_edges.py` | `EdgeDuplicate` | `fact_type_reasoning: str` - 解释边类型分类的原因 |
| `nodes.py` | `EntityNode` | `reasoning: str \| None` - LLM 的分类推理过程 |

**实体 reasoning 入库说明**:
- 实体的 reasoning 字段会持久化到图数据库的节点属性中
- 查询实体时从 `properties(n)` 中提取 reasoning 并返回给前端
- 边的 reasoning 不入库，仅用于提高 LLM 输出质量

**关键修改点**:
1. `EntityNode` 模型新增 `reasoning: str | None` 字段
2. `extract_nodes()` 函数在创建新节点时传递 reasoning
3. `add_nodes_and_edges_bulk_tx()` 在保存时包含 reasoning
4. `get_entity_node_from_record()` 从 attributes 中提取 reasoning（因为使用 `properties(n) AS attributes` 返回所有节点属性）

## 3.2 FalkorDB 字符串转义

**文件**: `graphiti_core/utils/bulk_utils.py`

**函数**: `_sanitize_string_for_falkordb()`

**目的**: 转义换行符等控制字符，防止 FalkorDB 查询解析错误。

## 3.3 非官方 OpenAI 兼容端点支持

**文件**: `graphiti_core/llm_client/openai_generic_client.py`

**目的**: 支持不支持 `response_format: json_schema` 的 OpenAI 兼容端点（如阿里 Qwen）。

## 3.4 严格控制边类型（非 Schema 边类型降级）

**文件**: `graphiti_core/utils/maintenance/edge_operations.py`

**位置**: `resolve_extracted_edge()` 函数中的边类型处理逻辑

**问题背景**:

原始 Graphiti 的边类型处理逻辑：
1. 如果是 Schema 允许的边类型 → 采用
2. 如果是 Schema 定义但不允许当前节点对 → 降级为 RELATES_TO
3. 如果是 LLM 自动生成的非 Schema 边类型 → **保留** ← 问题！

这导致 LLM 可能生成任意边类型名称（如 `DEVELOPED_IN`、`USES_PORT`），绕过 Schema 控制。

**修改**:

```python
# 修改前
elif not is_default_type:
    # Non-custom labels are allowed to pass through
    resolved_edge.name = fact_type  # 保留 LLM 生成的名称
    resolved_edge.attributes = {}

# 修改后
elif not is_default_type:
    # EasyOps customization: Non-schema edge types also degrade to DEFAULT
    resolved_edge.name = DEFAULT_EDGE_NAME  # 降级为 RELATES_TO
    resolved_edge.attributes = {}
```

**效果**: 只有 Schema 中明确定义的边类型才会被保留，其他一律降级为 `RELATES_TO`。

---
