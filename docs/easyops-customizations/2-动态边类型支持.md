# 2. 动态边类型支持

## 问题背景

原始 Graphiti 在批量保存边时，Cypher 查询硬编码了 `RELATES_TO` 作为关系类型：

```cypher
MERGE (source)-[r:RELATES_TO {uuid: edge.uuid}]->(target)
SET r = edge
```

这导致即使 LLM 正确识别了边类型（如 `DEPENDS_ON`），数据库中的关系类型仍然是 `RELATES_TO`，`edge.name` 只是一个属性而不是真正的关系类型。

## 具体表现

```
LLM 抽取结果:
  - source: agent (Component)
  - target: gateway (Component)
  - edge.name = "DEPENDS_ON"

数据库实际存储（修复前）:
  (agent)-[:RELATES_TO {name: "DEPENDS_ON"}]->(gateway)
           ↑ 关系类型错误

数据库实际存储（修复后）:
  (agent)-[:DEPENDS_ON {name: "DEPENDS_ON"}]->(gateway)
           ↑ 关系类型正确
```

## 修复方案

### 2.1 新增函数 `get_entity_edge_save_bulk_query_by_type()`

**文件**: `graphiti_core/models/edges/edge_db_queries.py`

**位置**: 在 `get_entity_edge_save_bulk_query()` 函数之后新增

```python
def get_entity_edge_save_bulk_query_by_type(provider: GraphProvider, edge_type: str) -> str:
    """Generate edge save query for a specific edge type.

    This is necessary because Cypher doesn't support dynamic relationship types.
    We generate a query with the edge type hardcoded in the MERGE clause.
    """
    # Sanitize edge_type to prevent injection (only allow alphanumeric and underscore)
    safe_edge_type = ''.join(c for c in edge_type if c.isalnum() or c == '_')
    if not safe_edge_type:
        safe_edge_type = 'RELATES_TO'

    match provider:
        case GraphProvider.FALKORDB:
            return f"""
                UNWIND $entity_edges AS edge
                MATCH (source:Entity {{uuid: edge.source_node_uuid}})
                MATCH (target:Entity {{uuid: edge.target_node_uuid}})
                MERGE (source)-[r:{safe_edge_type} {{uuid: edge.uuid}}]->(target)
                SET r = edge
                SET r.fact_embedding = vecf32(edge.fact_embedding)
                WITH r, edge
                RETURN edge.uuid AS uuid
            """
        case GraphProvider.NEPTUNE:
            return f"""
                UNWIND $entity_edges AS edge
                MATCH (source:Entity {{uuid: edge.source_node_uuid}})
                MATCH (target:Entity {{uuid: edge.target_node_uuid}})
                MERGE (source)-[r:{safe_edge_type} {{uuid: edge.uuid}}]->(target)
                SET r = removeKeyFromMap(removeKeyFromMap(edge, "fact_embedding"), "episodes")
                SET r.fact_embedding = join([x IN coalesce(edge.fact_embedding, []) | toString(x) ], ",")
                SET r.episodes = join(edge.episodes, ",")
                RETURN edge.uuid AS uuid
            """
        case _:
            # For Neo4j and others
            return f"""
                UNWIND $entity_edges AS edge
                MATCH (source:Entity {{uuid: edge.source_node_uuid}})
                MATCH (target:Entity {{uuid: edge.target_node_uuid}})
                MERGE (source)-[e:{safe_edge_type} {{uuid: edge.uuid}}]->(target)
                SET e += edge
                WITH e, edge
                CALL db.create.setRelationshipVectorProperty(e, "fact_embedding", edge.fact_embedding)
                RETURN edge.uuid AS uuid
            """
```

**安全性**: 使用 `safe_edge_type` 过滤非法字符，防止 Cypher 注入。

### 2.2 修改批量保存逻辑

**文件**: `graphiti_core/utils/bulk_utils.py`

**位置**: `add_nodes_and_edges_bulk_tx()` 函数末尾，替换原来的边保存逻辑

**修改前**:
```python
await tx.run(
    get_entity_edge_save_bulk_query(driver.provider),
    entity_edges=edges,
)
```

**修改后**:
```python
# Group edges by type and save each group with the correct relationship type
# This is necessary because Cypher doesn't support dynamic relationship types
edges_by_type: dict[str, list[dict[str, Any]]] = {}
for edge in edges:
    edge_type = edge.get('name', 'RELATES_TO')
    if edge_type not in edges_by_type:
        edges_by_type[edge_type] = []
    edges_by_type[edge_type].append(edge)

for edge_type, typed_edges in edges_by_type.items():
    query = get_entity_edge_save_bulk_query_by_type(driver.provider, edge_type)
    logger.info(f'[bulk_save] Saving {len(typed_edges)} edges of type {edge_type}')
    await tx.run(query, entity_edges=typed_edges)
```

**同时需要添加 import**:
```python
from graphiti_core.models.edges.edge_db_queries import (
    get_entity_edge_save_bulk_query,
    get_entity_edge_save_bulk_query_by_type,  # 新增
    get_episodic_edge_save_bulk_query,
)
```

## 验证方法

导入数据后，查询边类型分布：

```cypher
MATCH ()-[r]->()
RETURN type(r) as edge_type, count(*) as cnt
ORDER BY cnt DESC
```

修复前只会看到 `RELATES_TO` 和 `MENTIONS`，修复后会看到多种边类型。

---
